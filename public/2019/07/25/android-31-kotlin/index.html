

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="概述">
<meta property="og:type" content="article">
<meta property="og:title" content="重拾android路(三十一) Kotlin学习笔记">
<meta property="og:url" content="http://example.com/2019/07/25/android-31-kotlin/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-25T03:49:11.000Z">
<meta property="article:modified_time" content="2023-06-04T11:59:43.089Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="android">
<meta property="article:tag" content="kotlin">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>重拾android路(三十一) Kotlin学习笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="重拾android路(三十一) Kotlin学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-07-25 11:49" pubdate>
          2019年7月25日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          41k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          343 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">重拾android路(三十一) Kotlin学习笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>概述</p>
<span id="more"></span>
<p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。<br>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p>
<h1 id="kotlin继承android开发环境"><a href="#kotlin继承android开发环境" class="headerlink" title="kotlin继承android开发环境"></a>kotlin继承android开发环境</h1><p>在Android Studio3.0以后的版本，自动能够使用kotlin作为开发语言</p>
<h1 id="kotlin基础语法"><a href="#kotlin基础语法" class="headerlink" title="kotlin基础语法"></a>kotlin基础语法</h1><p>熟悉Java语言之后，Kotlin的上手简直不要太简单，直接开始总结</p>
<h2 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.runoob.main<br><br><span class="hljs-keyword">import</span> java.util.*<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。<br>如果没有指定包，默认为 <pre>default </pre>包。</p>
<h2 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h2><p>有几个包会默认导入到每个kotlin文件中，如下</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">kotlin.*<br>kotlin.annotation.*<br>kotlin.collections.*<br>kotlin.comparisons.*<br>kotlin.io.*<br>kotlin.ranges.*<br>kotlin.<span class="hljs-keyword">sequences</span>.*<br>kotlin.text.*<br></code></pre></td></tr></table></figure>

<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;   <span class="hljs-comment">// Int 参数，返回值 Int</span><br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure>

<p>表达式作为函数体，返回类型自动推断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> = a + b<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = a + b   <span class="hljs-comment">// public 方法则必须明确写出返回类型</span><br></code></pre></td></tr></table></figure>

<p>无返回值的函数(类似Java中的void)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printSum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Unit</span> &#123; <br>    print(a + b)<br>&#125;<br><br><br><span class="hljs-comment">// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printSum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> &#123; <br>    print(a + b)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="可变长参数函数"><a href="#可变长参数函数" class="headerlink" title="可变长参数函数"></a>可变长参数函数</h2><p>函数的变长参数可以用 vararg 关键字进行标识：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">vars</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> v:<span class="hljs-type">Int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vt <span class="hljs-keyword">in</span> v)&#123;<br>        print(vt)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    vars(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出12345</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> sumLambda: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123;x,y -&gt; x+y&#125;<br>    println(sumLambda(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))  <span class="hljs-comment">// 输出 3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="定义常量与变量"><a href="#定义常量与变量" class="headerlink" title="定义常量与变量"></a>定义常量与变量</h2><p>可变变量定义：var 关键字</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">var <span class="hljs-tag">&lt;<span class="hljs-name">标识符</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">类型</span>&gt;</span> = <span class="hljs-tag">&lt;<span class="hljs-name">初始化值</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">val <span class="hljs-tag">&lt;<span class="hljs-name">标识符</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">类型</span>&gt;</span> = <span class="hljs-tag">&lt;<span class="hljs-name">初始化值</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>常量与变量都可以没有初始化值,但是在引用前必须初始化<br>编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">val</span> b = <span class="hljs-number">1</span>       <span class="hljs-comment">// 系统自动推断变量类型为Int</span><br><span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Int</span>      <span class="hljs-comment">// 如果不在声明时初始化则必须提供变量类型</span><br>c = <span class="hljs-number">1</span>           <span class="hljs-comment">// 明确赋值</span><br><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>        <span class="hljs-comment">// 系统自动推断变量类型为Int</span><br>x += <span class="hljs-number">1</span>           <span class="hljs-comment">// 变量可修改</span><br></code></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Kotlin 支持单行和多行注释，实例如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 这是一个单行注释</span><br><br><span class="hljs-comment">/* 这是一个多行的</span><br><span class="hljs-comment">   块注释。 */</span><br></code></pre></td></tr></table></figure>

<p>与 Java 不同, Kotlin 中的块注释允许嵌套。</p>
<h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">$ 表示一个变量名或者变量值<br>$varName 表示变量值<br>$&#123;varName.<span class="hljs-keyword">fun</span>()&#125; 表示变量的方法返回值:<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-comment">// 模板中的简单名称：</span><br><span class="hljs-keyword">val</span> s1 = <span class="hljs-string">&quot;a is <span class="hljs-variable">$a</span>&quot;</span> <br><br>a = <span class="hljs-number">2</span><br><span class="hljs-comment">// 模板中的任意表达式：</span><br><span class="hljs-keyword">val</span> s2 = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;s1.replace(<span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;was&quot;</span>)&#125;</span>, but now is <span class="hljs-variable">$a</span>&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="NULL检查机制"><a href="#NULL检查机制" class="headerlink" title="NULL检查机制"></a>NULL检查机制</h2><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//类型后面加?表示可为空</span><br>var age: String? = <span class="hljs-string">&quot;23&quot;</span> <br><span class="hljs-comment">//抛出空指针异常</span><br><span class="hljs-keyword">val</span> ages = age!!.<span class="hljs-keyword">to</span><span class="hljs-constructor">Int()</span><br><span class="hljs-comment">//不做处理返回 null</span><br><span class="hljs-keyword">val</span> ages1 = age?.<span class="hljs-keyword">to</span><span class="hljs-constructor">Int()</span><br><span class="hljs-comment">//age为空返回-1</span><br><span class="hljs-keyword">val</span> ages2 = age?.<span class="hljs-keyword">to</span><span class="hljs-constructor">Int()</span> ?: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。<br>当 str 中的字符串内容不是一个整数时, 返回 null:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br>以下实例演示如何使用一个返回值可为 <span class="hljs-literal">null</span> 的函数:<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (args.size &lt; <span class="hljs-number">2</span>) &#123;<br>    print(<span class="hljs-string">&quot;Two integers expected&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">val</span> x = parseInt(args[<span class="hljs-number">0</span>])<br>  <span class="hljs-keyword">val</span> y = parseInt(args[<span class="hljs-number">1</span>])<br>  <span class="hljs-comment">// 直接使用 `x * y` 会导致错误, 因为它们可能为 null.</span><br>  <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span> &amp;&amp; y != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量</span><br>    print(x * y)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="类型检测及自动类型转换"><a href="#类型检测及自动类型转换" class="headerlink" title="类型检测及自动类型转换"></a>类型检测及自动类型转换</h2><p>我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getStringLength</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> String) &#123;<br>    <span class="hljs-comment">// 做过类型判断以后，obj会被系统自动转换为String类型</span><br>    <span class="hljs-keyword">return</span> obj.length <br>  &#125;<br><br>  <span class="hljs-comment">//在这里还有一种方法，与Java中instanceof不同，使用!is</span><br>  <span class="hljs-comment">// if (obj !is String)&#123;</span><br>  <span class="hljs-comment">//   // XXX</span><br>  <span class="hljs-comment">// &#125;</span><br><br>  <span class="hljs-comment">// 这里的obj仍然是Any类型的引用</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getStringLength</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;<br>  <span class="hljs-keyword">if</span> (obj !<span class="hljs-keyword">is</span> String)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  <span class="hljs-comment">// 在这个分支中, `obj` 的类型会被自动转换为 `String`</span><br>  <span class="hljs-keyword">return</span> obj.length<br>&#125;<br></code></pre></td></tr></table></figure>
<p>甚至还可以</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getStringLength</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;<br>  <span class="hljs-comment">// 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String`</span><br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> String &amp;&amp; obj.length &gt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> obj.length<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。<br>区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scss">for (i in <span class="hljs-number">1</span>..<span class="hljs-number">4</span>) <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">// 输出“1234”</span><br><br>for (i in <span class="hljs-number">4</span>..<span class="hljs-number">1</span>) <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">// 什么都不输出</span><br><br>if (i in <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 等同于 1 &lt;= i &amp;&amp; i &lt;= 10</span><br>    <span class="hljs-built_in">println</span>(i)<br>&#125;<br><br><span class="hljs-comment">// 使用 step 指定步长</span><br>for (i in <span class="hljs-number">1</span>..<span class="hljs-number">4</span> step <span class="hljs-number">2</span>) <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">// 输出“13”</span><br><br>for (i in <span class="hljs-number">4</span> downTo <span class="hljs-number">1</span> step <span class="hljs-number">2</span>) <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">// 输出“42”</span><br><br><br><span class="hljs-comment">// 使用 until 函数排除结束元素</span><br>for (i in <span class="hljs-number">1</span> until <span class="hljs-number">10</span>) &#123;   <span class="hljs-comment">// i in [1, 10) 排除了 10</span><br>     <span class="hljs-built_in">println</span>(i)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss">fun <span class="hljs-selector-tag">main</span>(args: Array&lt;String&gt;) &#123;<br>    <span class="hljs-built_in">print</span>(&quot;循环输出：&quot;)<br>    for (i in <span class="hljs-number">1</span>..<span class="hljs-number">4</span>) <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">// 输出“1234”</span><br>    <span class="hljs-built_in">println</span>(&quot;\n----------------&quot;)<br>    <span class="hljs-built_in">print</span>(&quot;设置步长：&quot;)<br>    for (i in <span class="hljs-number">1</span>..<span class="hljs-number">4</span> step <span class="hljs-number">2</span>) <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">// 输出“13”</span><br>    <span class="hljs-built_in">println</span>(&quot;\n----------------&quot;)<br>    <span class="hljs-built_in">print</span>(&quot;使用 downTo：&quot;)<br>    for (i in <span class="hljs-number">4</span> downTo <span class="hljs-number">1</span> step <span class="hljs-number">2</span>) <span class="hljs-built_in">print</span>(i) <span class="hljs-comment">// 输出“42”</span><br>    <span class="hljs-built_in">println</span>(&quot;\n----------------&quot;)<br>    <span class="hljs-built_in">print</span>(&quot;使用 until：&quot;)<br>    <span class="hljs-comment">// 使用 until 函数排除结束元素</span><br>    for (i in <span class="hljs-number">1</span> until <span class="hljs-number">4</span>) &#123;   <span class="hljs-comment">// i in [1, 4) 排除了 4</span><br>        <span class="hljs-built_in">print</span>(i)<br>    &#125;<br>    <span class="hljs-built_in">println</span>(&quot;\n----------------&quot;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位宽度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Double</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">Float</td>
<td align="left">32</td>
</tr>
<tr>
<td align="left">Long</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">Int</td>
<td align="left">32</td>
</tr>
<tr>
<td align="left">Short</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">Byte</td>
<td align="left">8</td>
</tr>
</tbody></table>
<h2 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h2><p>下面是所有类型的字面常量：</p>
<ol>
<li>十进制：123</li>
<li>长整型以大写的 L 结尾：123L</li>
<li>16 进制以 0x 开头：0x0F</li>
<li>2 进制以 0b 开头：0b00001011</li>
<li>注意：8进制不支持<br>Kotlin 同时也支持传统符号表示的浮点数值：</li>
</ol>
<ul>
<li>Doubles 默认写法: 123.5, 123.5e10</li>
<li>Floats 使用 f 或者 F 后缀：123.5f<br>你可以使用下划线使数字常量更易读：</li>
</ul>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">val</span> oneMillion = <span class="hljs-number">1_000_000</span><br><span class="hljs-keyword">val</span> creditCardNumber = <span class="hljs-number">1234_5678_9012_3456L</span><br><span class="hljs-keyword">val</span> socialSecurityNumber = <span class="hljs-number">999_99_9999L</span><br><span class="hljs-keyword">val</span> hexBytes = <span class="hljs-number">0xFF_EC_DE_5E</span><br><span class="hljs-keyword">val</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-number">0b11010010_01101001_10010100_10010010</span><br></code></pre></td></tr></table></figure>

<h2 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h2><p>Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所有在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。<br>在 Kotlin 中，三个等号 &#x3D;&#x3D;&#x3D; 表示比较对象地址，两个 &#x3D;&#x3D; 表示比较两个值大小。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span> = <span class="hljs-number">10000</span><br>    println(a === a) <span class="hljs-comment">// true，值相等，对象地址相等</span><br><br>    <span class="hljs-comment">//经过了装箱，创建了两个不同的对象</span><br>    <span class="hljs-keyword">val</span> boxedA: <span class="hljs-built_in">Int</span>? = a<br>    <span class="hljs-keyword">val</span> anotherBoxedA: <span class="hljs-built_in">Int</span>? = a<br><br>    <span class="hljs-comment">//虽然经过了装箱，但是值是相等的，都是10000</span><br>    println(boxedA === anotherBoxedA) <span class="hljs-comment">//  false，值相等，对象地址不一样</span><br>    println(boxedA == anotherBoxedA) <span class="hljs-comment">// true，值相等</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Byte</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// OK, 字面值是静态检测的</span><br><span class="hljs-keyword">val</span> i: <span class="hljs-built_in">Int</span> = b <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>

<p>我们可以代用其toInt()方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Byte</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// OK, 字面值是静态检测的</span><br><span class="hljs-keyword">val</span> i: <span class="hljs-built_in">Int</span> = b.toInt() <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure>

<p>每种数据类型都有下面的这些方法，可以转化为其它的类型：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">toByte</span><span class="hljs-params">()</span></span>: Byte<br><span class="hljs-function"><span class="hljs-title">toShort</span><span class="hljs-params">()</span></span>: Short<br><span class="hljs-function"><span class="hljs-title">toInt</span><span class="hljs-params">()</span></span>: Int<br><span class="hljs-function"><span class="hljs-title">toLong</span><span class="hljs-params">()</span></span>: Long<br><span class="hljs-function"><span class="hljs-title">toFloat</span><span class="hljs-params">()</span></span>: Float<br><span class="hljs-function"><span class="hljs-title">toDouble</span><span class="hljs-params">()</span></span>: Double<br><span class="hljs-function"><span class="hljs-title">toChar</span><span class="hljs-params">()</span></span>: Char<br></code></pre></td></tr></table></figure>

<p>有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">val</span> l = <span class="hljs-number">1</span>L + <span class="hljs-number">3</span> // Long + Int =&gt; Long<br></code></pre></td></tr></table></figure>

<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>对于Int和Long类型，还有一系列的位操作符可以使用，分别是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">shl</span><span class="hljs-params">(bits)</span></span> – 左移位 (Java’s &lt;&lt;)<br><span class="hljs-function"><span class="hljs-title">shr</span><span class="hljs-params">(bits)</span></span> – 右移位 (Java’s &gt;&gt;)<br><span class="hljs-function"><span class="hljs-title">ushr</span><span class="hljs-params">(bits)</span></span> – 无符号右移位 (Java’s &gt;&gt;&gt;)<br><span class="hljs-function"><span class="hljs-title">and</span><span class="hljs-params">(bits)</span></span> – 与<br><span class="hljs-function"><span class="hljs-title">or</span><span class="hljs-params">(bits)</span></span> – 或<br><span class="hljs-function"><span class="hljs-title">xor</span><span class="hljs-params">(bits)</span></span> – 异或<br><span class="hljs-function"><span class="hljs-title">inv</span><span class="hljs-params">()</span></span> – 反向<br></code></pre></td></tr></table></figure>

<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ‘ 包含起来的。比如普通字符 ‘0’，’a’。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">check</span><span class="hljs-params">(c: <span class="hljs-type">Char</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 错误：类型不兼容</span><br>        <span class="hljs-comment">// ……</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>字符字面值用单引号括起来: ‘1’。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\t、 \b、\n、\r、&#39;、&quot;、\ 和 $。 编码其他字符要用 Unicode 转义序列语法：’\uFF00’。<br>我们可以显式把字符转换为 Int 数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">decimalDigitValue</span><span class="hljs-params">(c: <span class="hljs-type">Char</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">if</span> (c !<span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;0&#x27;</span>..<span class="hljs-string">&#x27;9&#x27;</span>)<br>        <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;Out of range&quot;</span>)<br>    <span class="hljs-keyword">return</span> c.toInt() - <span class="hljs-string">&#x27;0&#x27;</span>.toInt() <span class="hljs-comment">// 显式转换为数字</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。</p>
<h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>布尔用 Boolean 类型表示，它有两个值：true 和 false。<br>若需要可空引用布尔会被装箱。<br>内置的布尔运算有：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|| – 短路逻辑或</span><br><span class="hljs-meta">&amp;&amp; – 短路逻辑与</span><br>! - 逻辑非<br></code></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。<br>数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-comment">//[1,2,3]</span><br>    <span class="hljs-keyword">val</span> a = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-comment">//[0,2,4]</span><br>    <span class="hljs-keyword">val</span> b = Array(<span class="hljs-number">3</span>, &#123; i -&gt; (i * <span class="hljs-number">2</span>) &#125;)<br><br>    <span class="hljs-comment">//读取数组内容</span><br>    println(a[<span class="hljs-number">0</span>])    <span class="hljs-comment">// 输出结果：1</span><br>    println(b[<span class="hljs-number">1</span>])    <span class="hljs-comment">// 输出结果：2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如上所述，[] 运算符代表调用成员函数 get() 和 set()。<br>注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。<br>除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">val</span> x: IntArray = intArrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-attribute">x</span>[<span class="hljs-number">0</span>] = x[<span class="hljs-number">1</span>] + x[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>和 Java 一样，String 是不可变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">for (c in str) &#123;<br>    <span class="hljs-built_in">println</span>(c)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pony"><span class="hljs-keyword">fun</span> main(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;) &#123;<br>    <span class="hljs-meta">val</span> text = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    多行字符串</span><br><span class="hljs-string">    多行字符串</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    println(text)   <span class="hljs-comment">// 输出有一些前置空格</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>String 可以通过 trimMargin() 方法来删除多余的空白。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pony"><span class="hljs-keyword">fun</span> main(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;) &#123;<br>    <span class="hljs-meta">val</span> text = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    |多行字符串</span><br><span class="hljs-string">    |菜鸟教程</span><br><span class="hljs-string">    |多行字符串</span><br><span class="hljs-string">    |Runoob</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.trimMargin()<br>    println(text)    <span class="hljs-comment">// 前置空格删除了</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(“&gt;”)。</p>
<h2 id="字符串模板-1"><a href="#字符串模板-1" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> i = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;i = <span class="hljs-variable">$i</span>&quot;</span> <span class="hljs-comment">// 求值结果为 &quot;i = 10&quot;</span><br>    println(s)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>或者用花括号扩起来的任意表达式:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;runoob&quot;</span><br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;<span class="hljs-variable">$s</span>.length is <span class="hljs-subst">$&#123;s.length&#125;</span>&quot;</span> <span class="hljs-comment">// 求值结果为 &quot;runoob.length is 6&quot;</span><br>    println(str)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">fun main(args: Array&lt;String&gt;) &#123;<br>    val price = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    $&#123;&#x27;$&#x27;&#125;9.99</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    println(price)  <span class="hljs-regexp">//</span> 求值结果为 <span class="hljs-variable">$9</span>.<span class="hljs-number">99</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><h2 id="IF表达式"><a href="#IF表达式" class="headerlink" title="IF表达式"></a>IF表达式</h2><p>一个if语句包含一个布尔表达式和一条或多条语句</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 普通用法</span><br><span class="hljs-selector-tag">var</span> max = <span class="hljs-selector-tag">a</span><br><span class="hljs-keyword">if</span> (<span class="hljs-selector-tag">a</span> &lt; b) max = <span class="hljs-selector-tag">b</span><br><br><span class="hljs-comment">// 使用else</span><br><span class="hljs-selector-tag">var</span> max: Int<br><span class="hljs-keyword">if</span> (<span class="hljs-selector-tag">a</span> &gt; b)&#123;<br>  max = <span class="hljs-selector-tag">a</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  max = <span class="hljs-selector-tag">b</span><br>&#125;<br><br><span class="hljs-comment">// 作为表达式</span><br>val max = <span class="hljs-keyword">if</span> (<span class="hljs-selector-tag">a</span> &gt; b) <span class="hljs-selector-tag">a</span> <span class="hljs-keyword">else</span> b<br></code></pre></td></tr></table></figure>

<p>我们也可以吧IF语句的表达式的结果赋值给一个变量</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">val max = <span class="hljs-keyword">if</span> (<span class="hljs-selector-tag">a</span> &gt; b)&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;选择a&quot;</span>)<br>  <span class="hljs-selector-tag">a</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;选择b&quot;</span>)<br>  <span class="hljs-selector-tag">b</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这也说明我们不需要像java那样有三元运算符，因为我们可以使用他的简单实现</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">val</span> c <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> (condition) a <span class="hljs-keyword">else</span> b<br></code></pre></td></tr></table></figure>

<p>一个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> x= <span class="hljs-number">0</span><br>  <span class="hljs-keyword">if</span>(x &gt;<span class="hljs-number">0</span>)&#123;<br>    println(<span class="hljs-string">&quot;x 大于0&quot;</span>)<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)&#123;<br>    println(<span class="hljs-string">&quot;x 等于0&quot;</span>)<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    println(<span class="hljs-string">&quot;x 小于0&quot;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">val</span> c = <span class="hljs-keyword">if</span>(a&gt;=b) a <span class="hljs-keyword">else</span> b<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> 等于 <span class="hljs-number">0</span><br><span class="hljs-attribute">c</span> 的值为 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="使用区间"><a href="#使用区间" class="headerlink" title="使用区间"></a>使用区间</h2><p>使用in运算符来检测某个数字是否在指定区间内</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> x = <span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">val</span> y = <span class="hljs-number">9</span>;<br>  <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.8</span>)&#123;<br>    println(<span class="hljs-string">&quot;x 在区间内&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h2><p>when将他的参数和所有的分支条件顺序比较，直到某个分支满足条件<br>when既可以被当做表达式使用也可以被当做语句使用，如果它被当作表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用，则忽略个别分支的值<br>when类似java语言中的switch</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">when</span>(<span class="hljs-variable">x</span>)&#123;</span><br><span class="hljs-function">  <span class="hljs-number">1</span> -&gt; <span class="hljs-title">print</span>(<span class="hljs-string">&quot;x= 1&quot;</span>)</span><br>  <span class="hljs-number">2</span> -&gt; <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;x=2&quot;</span>)</span><br>  <span class="hljs-variable"><span class="hljs-keyword">else</span></span> -&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;x 不是1，也不是2&quot;</span>)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在when中，else同switch的default，如果其他分支都不满足条件则会求值else分支<br>如果很多分支需要相同的方式出里，则可以把多个分支条件放在一起，用逗号隔开</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">when</span>(x)&#123;<br>  <span class="hljs-number">0</span>,<span class="hljs-number">1</span> -&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x=0或者x=1&quot;</span>)<br>  <span class="hljs-keyword">else</span> -&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;otherwise&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以检测一个值在(in) 或者不在(!in)一个区间或者集合中</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">when</span>(<span class="hljs-variable">x</span>)&#123;</span><br><span class="hljs-function">  <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> -&gt; <span class="hljs-title">print</span>(<span class="hljs-string">&quot;x 在1到10之间&quot;</span>)</span><br>  <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">validNumbers</span> -&gt; <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;x 是有效数字&quot;</span>)</span><br>  <span class="hljs-variable">!in</span> <span class="hljs-number">10</span>..<span class="hljs-number">20</span> -&gt; <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;想不在10到20之间&quot;</span>)</span><br>  <span class="hljs-variable"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&quot;以上都不是&quot;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>另一种可能性是检测一个是是(is)或不是(!is)一个特定类型的值，注意如果是只能转换，我们可以访问该类型的方法和属性而无需任何额外的检测</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(x:<span class="hljs-type">Any</span>)</span></span> = <span class="hljs-keyword">when</span>(x)&#123;<br>  <span class="hljs-keyword">is</span> String -&gt; x.startWith(<span class="hljs-string">&quot;xxx&quot;</span>)<br>  <span class="hljs-keyword">else</span> -&gt; <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>when也可以用来替换if-else语句，如果不提供参数，所有的分支条件都是简单布尔表达式，而当一个分支的条件为真时执行该分支</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">when</span>&#123;<br>  x.isOdd<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x是老版本&quot;</span>)<br>  x.isEven<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-built_in">print</span>()<br>  <span class="hljs-keyword">else</span> -&gt; <span class="hljs-built_in">print</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">when</span> (x) &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span> -&gt; println(<span class="hljs-string">&quot;x == 0 or x == 1&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;otherwise&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">when</span> (x) &#123;<br>        <span class="hljs-number">1</span> -&gt; println(<span class="hljs-string">&quot;x == 1&quot;</span>)<br>        <span class="hljs-number">2</span> -&gt; println(<span class="hljs-string">&quot;x == 2&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; &#123; <span class="hljs-comment">// 注意这个块</span><br>            println(<span class="hljs-string">&quot;x 不是 1 ，也不是 2&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">when</span> (x) &#123;<br>        <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span> -&gt; println(<span class="hljs-string">&quot;x 在该区间范围内&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;x 不在该区间范围内&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环可以对任何提供迭代器的对象进行遍历，例如for循环<br>如果我们想要通过索引遍历一个数组或者list，我们就可以这么做</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(x in array.indices)</span></span>&#123;<br>  <span class="hljs-built_in">print</span>(array<span class="hljs-selector-attr">[x]</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意上面，在区间上遍历会编译成优化的实现而不会创建额外的对象<br>或者我们可以使用库函数withIndex</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">((index,value)</span></span> <span class="hljs-keyword">in</span> array<span class="hljs-selector-class">.withInde</span>())&#123;<br>  <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the element at $index is $value&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> items = listOf(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;my name&quot;</span>,<span class="hljs-string">&quot;paulniu&quot;</span>)<br>  <span class="hljs-keyword">for</span>(item <span class="hljs-keyword">in</span> items)&#123;<br>    println(item)<br>  &#125;<br>  <span class="hljs-keyword">for</span>(index <span class="hljs-keyword">in</span> items.indices)&#123;<br>    println(<span class="hljs-string">&quot;item at <span class="hljs-variable">$index</span> is <span class="hljs-subst">$&#123;items[index]&#125;</span>&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>除了上面的方式之外，我们还可以通过增强for循环遍历数组或者集合</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">val</span> items <span class="hljs-operator">=</span> listOf(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;my name&quot;</span>,<span class="hljs-string">&quot;paulniu&quot;</span>)<br>items.<span class="hljs-keyword">forEach</span>&#123; item <span class="hljs-operator">-&gt;</span> <br>  println(item)  <br>&#125;<br>打印结果就是<br><span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;my name&quot;</span>,<span class="hljs-string">&quot;paulniu&quot;</span><br></code></pre></td></tr></table></figure>
<p>如果我们想获取每个item的下标，可以通过带index的for循环，来实现</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">val <span class="hljs-built_in">items</span> = listOf(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;my name&quot;</span>,<span class="hljs-string">&quot;paulniu&quot;</span>)<br><span class="hljs-built_in">items</span>.forEachIndex&#123; <span class="hljs-built_in">index</span>,item -&gt;<br>  println(<span class="hljs-string">&quot;index=&quot;</span>+<span class="hljs-built_in">index</span>+<span class="hljs-string">&quot;;item=&quot;</span> +item)<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>当我们想要输出字符串时，可以通过**${}**的方式实现，例如上面的例子，我们可以这样写</p>
</blockquote>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">val items = listOf(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;my name&quot;</span>,<span class="hljs-string">&quot;paulniu&quot;</span>)<br>items.forEachIndex&#123; <span class="hljs-keyword">index</span>,item -&gt; <br>  println(<span class="hljs-string">&quot;index=<span class="hljs-subst">$&#123;<span class="hljs-keyword">index</span>&#125;</span>;item=<span class="hljs-subst">$&#123;item&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="while和do…while循环"><a href="#while和do…while循环" class="headerlink" title="while和do…while循环"></a>while和do…while循环</h2><p>while循环是最基本的循环<br>do…while循环对于while循环来说，如果不满足条件则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次<br>do…while循环和while循环相似，不同的是，do…while循环至少会执行一次<br>一个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> x= <span class="hljs-number">5</span><br>  <span class="hljs-keyword">while</span>(x &gt;<span class="hljs-number">0</span>)&#123;<br>    print(x--)<br>  &#125;<br>  <span class="hljs-keyword">var</span> y = <span class="hljs-number">5</span><br>  <span class="hljs-keyword">do</span>&#123;<br>    println(y--)<br>  &#125;<span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h2><p>Kotlin有三种结构化跳转表达式</p>
<ol>
<li>return 默认从最直接包围他的函数或匿名函数返回</li>
<li>break 终止最直接包围他的训话</li>
<li>continue 继续下一次最直接包围他的循环<br>在循环中Kotlin支持传统的break和continue操作符<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i==<span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>  <span class="hljs-comment">// i 为 3 时跳过当前循环，继续下一次循环</span><br>        println(i)<br>        <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">5</span>) <span class="hljs-keyword">break</span>   <span class="hljs-comment">// i 为 6 时 跳出循环</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="Break和Continue标签"><a href="#Break和Continue标签" class="headerlink" title="Break和Continue标签"></a>Break和Continue标签</h4><p>在Kotlin中任何表达式都可以用标签(label)标记，标签格式为标识符后面跟@符号</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-symbol">loop@</span> <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.100</span>) &#123;<br>    <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.100</span>) &#123;<br>        <span class="hljs-keyword">if</span> (……) <span class="hljs-keyword">break</span><span class="hljs-symbol">@loop</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>标签限制的break跳转到刚好位于该标签指定的循环后面的执行点，continue继续标签指定的循环的下一次迭代</p>
<h4 id="标签返回"><a href="#标签返回" class="headerlink" title="标签返回"></a>标签返回</h4><p>Kotlin有函数字面量，局部函数和对象表达式，因此Kotlin的函数可以被嵌套。标签限制的return允许我们从外层函数返回。最重要的一个用途就是从lambda表达式中返回，例如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>  ints.forEach&#123;<br>    <span class="hljs-keyword">if</span>(it == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br>    print(it)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个return表达式从最直接包围他的函数即f行数中返回(注意这种非局部的返回只支持传给内联函数的lambda表达式)。如果我们需要从lambda表达式中返回，则必须给它加标签并用以限制return</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    ints.forEach <span class="hljs-symbol">lit@</span> &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@lit</span><br>        print(it)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>Kotlin类包含：构造函数和初始化代码块，函数，属性，内部类，对象声明<br>Kotlin使用关键字class声明类，后面紧跟类名</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span>&#123;<br><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 同时我们也可以声明一个空类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span><br></code></pre></td></tr></table></figure>

<h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><h4 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h4><p>类的属性可以使用关键字var声明为可变的，否则使用只读关键字val声明为不可变</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>&#123;<br>  <span class="hljs-keyword">var</span> name:<span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">var</span> age:Int = <span class="hljs-number">22</span><br>  <span class="hljs-keyword">var</span> address: <span class="hljs-built_in">String</span>=<span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以使用普通函数那样使用构造函数创建类实例</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> <span class="hljs-built_in">demo</span> = Demo()// 注意Kotlin中没有<span class="hljs-built_in">new</span>关键字<br></code></pre></td></tr></table></figure>
<p>如果要使用一个属性，直接用名称引用即可</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">demo</span>.name<br><span class="hljs-built_in">demo</span>.age<br></code></pre></td></tr></table></figure>
<p>Kotlin中类可以有一个主构造器，以及一个或多个次构造器，主构造器是类头的一部分，位于类名称之后</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span> Person <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">name</span>:<span class="hljs-keyword">String</span>)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure>
<p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">name:<span class="hljs-symbol">String</span></span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h4><p>getter和setter都是可选的，如果属性类型可以从初始化语句或者类的成员函数中推断出来，那也可以省略类型，val不允许设置setter函数，因为他是只读的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> allByDefault:<span class="hljs-built_in">Int</span>? <span class="hljs-comment">// 错误，需要一个初始化语句，默认实现了getter和setter方法</span><br><span class="hljs-keyword">var</span> initialized = <span class="hljs-number">1</span>   <span class="hljs-comment">// 类型为Int，默认实现了getter和setter方法</span><br><span class="hljs-keyword">val</span> simple:<span class="hljs-built_in">Int</span>?       <span class="hljs-comment">// 类型为Int，默认实现了getter方法，但必须在构造函数中初始化</span><br><span class="hljs-keyword">val</span> inferredType = <span class="hljs-number">1</span>  <span class="hljs-comment">// 类型为Int类型，默认实现了getter方法</span><br></code></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-keyword">var</span> lastName:String = <span class="hljs-string">&quot;wang&quot;</span><br>      <span class="hljs-keyword">get</span>() = field.toUpperCase()     <span class="hljs-comment">// 将变量赋值后转换为大写</span><br>      <span class="hljs-keyword">set</span><br>  <span class="hljs-keyword">var</span> no: <span class="hljs-built_in">Int</span> = <span class="hljs-number">100</span><br>      <span class="hljs-keyword">get</span>() = field                   <span class="hljs-comment">// 后端变量</span><br>      <span class="hljs-keyword">set</span>(value)&#123;<br>        <span class="hljs-keyword">if</span>(value &lt; <span class="hljs-number">10</span>)&#123;<br>          field = value<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          field = -<span class="hljs-number">1</span><br>        &#125;<br>      &#125;<br>  <span class="hljs-keyword">var</span> height:<span class="hljs-built_in">Float</span> = <span class="hljs-number">123.45f</span><br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>        <br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> person = Person()<br>  person.lastName = <span class="hljs-string">&quot;lee&quot;</span><br>  println(<span class="hljs-string">&quot;lastName: <span class="hljs-subst">$&#123;person.lastName&#125;</span>&quot;</span>)<br>  person.no = <span class="hljs-number">9</span><br>  println(<span class="hljs-string">&quot;no: <span class="hljs-subst">$&#123;person.no&#125;</span>&quot;</span>)<br>  person.no = <span class="hljs-number">20</span><br>  println(<span class="hljs-string">&quot;no: <span class="hljs-subst">$&#123;person.no&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">lastName:</span>LEE<br><span class="hljs-symbol">no:</span><span class="hljs-number">9</span><br><span class="hljs-symbol">no:</span><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>

<p>Kotlin中类不能有字段，提供了后端变量机制，备用字段使用field关键字声明，field关键字只能用于属性的访问器</p>
<p>非空属性必须在定义的时候初始化，Kotlin提供了一种可以延迟初始化的方案，使用lateinit关键字描述属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> sub:TestSubject<br>  <span class="hljs-meta">@SetUp</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span></span>&#123;<br>    sub = TestSubject()<br>  &#125;<br>  <span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    sub.method()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h3><p>主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用init关键字作为前缀</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span> Person <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">name</span>:<span class="hljs-keyword">String</span>)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  init&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    printlin(&quot;name is $name&quot;)</span></span><br><span class="hljs-comment"><span class="hljs-function">  &#125;</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
<p>注意：主构造器的参数可以在初始化代码段中使用，也可以再累主题定义的属性初始化代码中使用<br>一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 我们创建一个person类，然后通过构造函数传入person的姓名，年龄，地址等信息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">constructor</span>(name:string,age:<span class="hljs-built_in">Int</span>,address:String)&#123;<br>  <span class="hljs-comment">// 此处为类体构成</span><br>  <br>  <span class="hljs-comment">// 初始化代码段</span><br>  <span class="hljs-keyword">init</span>&#123;<br>    println(<span class="hljs-string">&quot;初始化一个person信息，姓名是&quot;</span>+$name +<span class="hljs-string">&quot;;年龄是&quot;</span>+$age+<span class="hljs-string">&quot;;地址是&quot;</span>+$address)<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> person = Person(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">22</span>,<span class="hljs-string">&quot;北京市海淀区&quot;</span>)<br>  println(person.name)<br>  println(person.age)<br>  println(person.address)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p>类也可以有二级构造函数，需要在前面加上constructor关键字</p>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">parent</span>:<span class="hljs-params">Person</span>)&#123;<br>    <span class="hljs-variable">parent</span>.<span class="hljs-property">children</span>.<span class="hljs-property">add</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果类有主构造函数，每个次构造函数或者直接或者间接通过另一个次构造函数代理主构造函数，在同一个类中代理另一个构造函数使用this关键字</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">val</span> <span class="hljs-symbol">name:<span class="hljs-symbol">String</span></span>)&#123;<br>  constructor(name:String,age:<span class="hljs-built_in">int</span>):<span class="hljs-keyword">this</span>(name)&#123;<br>    <span class="hljs-comment">// 执行初始化操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果一个非抽象类没有声明构造函数(包括主构造函数和次构造函数)，它会产生一个没有参数的构造函数，构造函数都是public，如果我们不想我们的类有公共的构造函数，那么我们就必须声明一个空的主构造函数</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span> DontCreateMe <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function"></span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：在JVM虚拟机中，如果主构造函数的所有参数都有默认值，编译器就会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值</p>
</blockquote>
<p>一个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">constructor</span>(name:String)&#123;<br>  <span class="hljs-keyword">var</span> url:String= <span class="hljs-string">&quot;http://www.baidu.com&quot;</span><br>  <span class="hljs-keyword">var</span> country:String = <span class="hljs-string">&quot;CN&quot;</span><br>  <span class="hljs-keyword">var</span> siteName = name<br><br>  <span class="hljs-keyword">init</span>&#123;<br>    println(<span class="hljs-string">&quot;初始化网站名称: <span class="hljs-subst">$&#123;name&#125;</span>&quot;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 次构造函数</span><br>  <span class="hljs-keyword">constructor</span> (name:String,age:<span class="hljs-built_in">Int</span>) :<span class="hljs-keyword">this</span>(name)&#123;<br>    println(<span class="hljs-string">&quot;age 是： <span class="hljs-variable">$age</span>&quot;</span>)<br>  &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> website = MyClass(<span class="hljs-string">&quot;http://www.paulniu.com&quot;</span>,<span class="hljs-number">22</span>)<br>  println(website.siteName)<br>  println(website.url)<br>  println(website.country)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象是面向对象编程的特征之一，类本身或者类中的部分成员都是可以声明为abstract的。抽象成员在类中不存在具体的实现.注意：无需对抽象类或者抽象成员标注open注解</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>  <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br><br>  &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myAAA</span>:<span class="hljs-type">Base</span>()&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>我们可以把类嵌套在其他类中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;                  <span class="hljs-comment">// 外部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bar: <span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Nested</span> &#123;             <span class="hljs-comment">// 嵌套类</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> = <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> demo = Outer.Nested().foo() <span class="hljs-comment">// 调用格式：外部类.嵌套类.嵌套类方法/属性</span><br>    println(demo)    <span class="hljs-comment">// == 2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类使用inner关键字表示<br>内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bar: <span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> v = <span class="hljs-string">&quot;成员属性&quot;</span><br>    <span class="hljs-comment">/**嵌套内部类**/</span><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> = bar  <span class="hljs-comment">// 访问外部类成员</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerTest</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">this</span><span class="hljs-symbol">@Outer</span> <span class="hljs-comment">//获取外部类的成员变量</span><br>            println(<span class="hljs-string">&quot;内部类可以引用外部类的成员，例如：&quot;</span> + o.v)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> demo = Outer().Inner().foo()<br>    println(demo) <span class="hljs-comment">//   1</span><br>    <span class="hljs-keyword">val</span> demo2 = Outer().Inner().innerTest()   <br>    println(demo2)   <span class="hljs-comment">// 内部类可以引用外部类的成员，例如：成员属性</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>使用对象表达式来创建匿名内部类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">var</span> v = <span class="hljs-string">&quot;成员属性&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setInterFace</span><span class="hljs-params">(test: <span class="hljs-type">TestInterFace</span>)</span></span> &#123;<br>        test.test()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestInterFace</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> test = Test()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 采用对象表达式来创建接口对象，即匿名内部类的实例。</span><br><span class="hljs-comment">     */</span><br>    test.setInterFace(<span class="hljs-keyword">object</span> : TestInterFace &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;对象表达式创建匿名内部类的实例&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><p>类的修饰符包括两个</p>
<ol>
<li>classModifier:类属性修饰符，标示类本身特性</li>
</ol>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">abstract</td>
<td align="left">抽象类</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">类不可继承，默认属性</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">枚举类</td>
</tr>
<tr>
<td align="left">open</td>
<td align="left">类可继承，类默认是final的</td>
</tr>
<tr>
<td align="left">annotation</td>
<td align="left">注解类</td>
</tr>
</tbody></table>
<ol start="2">
<li>accessModifier：访问权限修饰符</li>
</ol>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">private</td>
<td align="left">仅在同一个文件中可见</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">同一个文件中或子类可见</td>
</tr>
<tr>
<td align="left">public</td>
<td align="left">所有调用的地方都可见</td>
</tr>
<tr>
<td align="left">internal</td>
<td align="left">同一个模块中可见</td>
</tr>
</tbody></table>
<p>一个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 文件名：example.kt</span><br><span class="hljs-keyword">package</span> foo<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;&#125; <span class="hljs-comment">// 在 example.kt 内可见</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> bar: <span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span> <span class="hljs-comment">// 该属性随处可见</span><br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> baz = <span class="hljs-number">6</span>    <span class="hljs-comment">// 相同模块内可见</span><br></code></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>Kotlin中所有类都继承自Any类，他是所有类的超类，对于没有超类型声明的类是默认超类</p>
<p>Any默认提供了三个函数</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">equals</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>注意：Any不是java中的Object</p>
<p>如果一个类要被继承，可以使用open关键字进行修饰</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">open <span class="hljs-keyword">class</span> <span class="hljs-symbol">Base</span>(<span class="hljs-symbol">p:<span class="hljs-symbol">Int</span></span>)&#123;<br>  <span class="hljs-comment">// 定义基类</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Text</span>(<span class="hljs-symbol">p:<span class="hljs-symbol">Int</span></span>):<span class="hljs-symbol">Base</span>(<span class="hljs-symbol">p</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="子类有主构造函数"><a href="#子类有主构造函数" class="headerlink" title="子类有主构造函数"></a>子类有主构造函数</h3><p>如果子类中有主构造函数，则基类必须在主构造函数中立即初始化</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">open <span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">ver</span> <span class="hljs-symbol">name:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">var</span></span> <span class="hljs-symbol">age:<span class="hljs-symbol">Int</span></span>)&#123;<br>  <span class="hljs-comment">// 基类</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span>(<span class="hljs-symbol">name:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">age</span>:<span class="hljs-symbol">Int</span>,<span class="hljs-symbol">var</span></span> <span class="hljs-symbol">no:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">var</span></span> <span class="hljs-symbol">score:<span class="hljs-symbol">Int</span></span>) :<span class="hljs-symbol">Person</span>(<span class="hljs-symbol">name,<span class="hljs-symbol">age</span></span>)&#123;<br><br>&#125;<br><br><span class="hljs-comment">// 测试</span><br>fun main(args:Array&lt;String&gt;)&#123;<br>  var s = Student(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;s123456&quot;</span>,<span class="hljs-number">89</span>)<br>  println(<span class="hljs-string">&quot;学生姓名是：$&#123;s.name&#125;&quot;</span><br>  println(<span class="hljs-string">&quot;学生年龄是：$(s.age)&quot;</span>))<br>  println(<span class="hljs-string">&quot;学生号是：$&#123;s.no&#125;&quot;</span>)<br>  println(<span class="hljs-string">&quot;成绩是：$&#123;s.score&#125;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="子类没有主构造函数"><a href="#子类没有主构造函数" class="headerlink" title="子类没有主构造函数"></a>子类没有主构造函数</h3><p>如果子类没有主构造函数，则必须在每一个二级构造函数中使用super关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span> Student:Person<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  constructor(ctx:Context):super(ctx)&#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  &#125;</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(ctx;Context,attrs:AttributeSet)</span> :</span>Super(ctx,attrs)<span class="hljs-comment">&#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>


<p>一个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(name:String)&#123;<br>  <span class="hljs-comment">// 次级构造函数</span><br>  <span class="hljs-keyword">constructor</span>(name:String,age:<span class="hljs-built_in">Int</span>):<span class="hljs-keyword">this</span>(name)&#123;<br>    <span class="hljs-comment">// 初始化操作</span><br>    println(<span class="hljs-string">&quot;-------------基本次级构造函数-------------&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类继承Person类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<span class="hljs-type">Person</span>&#123;<br>  <span class="hljs-comment">// 次级构造函数</span><br>  contructor(name:String,age:<span class="hljs-built_in">Int</span>,no:String,score:<span class="hljs-built_in">Int</span>):<span class="hljs-keyword">super</span>(name,age)&#123;<br>    println(<span class="hljs-string">&quot;学生姓名是：<span class="hljs-subst">$&#123;name&#125;</span>&quot;</span><br>  println(<span class="hljs-string">&quot;学生年龄是：$(age)&quot;</span>))<br>  println(<span class="hljs-string">&quot;学生号是：<span class="hljs-subst">$&#123;no&#125;</span>&quot;</span>)<br>  println(<span class="hljs-string">&quot;成绩是：<span class="hljs-subst">$&#123;score&#125;</span>&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写，如果要允许子类重写，就要手动添加关键字open，子类重写时使用override关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 用户基类</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 允许子类重写</span><br>    println(<span class="hljs-string">&quot;gogogo&quot;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 子类继承Person类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<span class="hljs-type">Person</span>()&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 重写父类方法</span><br>    println(<span class="hljs-string">&quot;hahaha&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> ss = Student()<br>  s.study()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>入股有很多相同的方法(继承或者实现自其它类)，则必须重写该方法，使用super规范去选择性的调用父类的实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>  <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>    print(<span class="hljs-string">&quot;A&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="属性重写"><a href="#属性重写" class="headerlink" title="属性重写"></a>属性重写</h2><p>属性重写使用override关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br>  <span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> x:<span class="hljs-built_in">Int</span> <span class="hljs-keyword">get</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">class1</span> : <span class="hljs-type">Foo</span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> x:<span class="hljs-built_in">Int</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可用var属性来重写一个val属性，但反过来是不行的。因为val属性本身就定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法<br>可以在主构造函数中使用override关键字作为属性声明的一部分</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Foo</span>&#123;<br>  val count:Int<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">class1</span>(<span class="hljs-symbol">override</span> <span class="hljs-symbol">val</span> <span class="hljs-symbol">count:<span class="hljs-symbol">Int</span></span>):<span class="hljs-symbol">Foo</span><br><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">class2:<span class="hljs-symbol">Foo</span></span>&#123;<br>  <span class="hljs-keyword">override</span> var count:Int = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有几点需要注意：</p>
<ol>
<li><p>子类继承父类是，不能有跟父类同名的变量，除非父类中该变量为private，或者父类中该变量为open，并且子类使用override关键字重写，如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">open <span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">var</span> <span class="hljs-symbol">name:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">var</span></span> <span class="hljs-symbol">age:<span class="hljs-symbol">Int</span></span>)&#123;<br>  open var sex: String = <span class="hljs-string">&quot;unknow&quot;</span><br>  init&#123;<br>    println(<span class="hljs-string">&quot;执行父类的构造方法&quot;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 子类的主构造方法的那么前面也加了var，这是不允许的，会报错</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span>(<span class="hljs-symbol">var</span> <span class="hljs-symbol">name:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">var</span></span> <span class="hljs-symbol">age:<span class="hljs-symbol">Int</span>,<span class="hljs-symbol">var</span></span> <span class="hljs-symbol">no:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">var</span></span> <span class="hljs-symbol">score:<span class="hljs-symbol">Int</span></span>):<span class="hljs-symbol">Person</span>(<span class="hljs-symbol">name,<span class="hljs-symbol">age</span></span>)&#123;<br>  <span class="hljs-keyword">override</span> var sex:String =<span class="hljs-string">&quot;male&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>子类不一定调用父类和接口中共同拥有的的同名方法</p>
</li>
</ol>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>Kotlin接口和java8类似，使用关键字interface关键自定义接口，允许方法有默认实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>:<span class="hljs-type">MyInterface</span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 可选的方法体</span><br>        println(<span class="hljs-string">&quot;foo&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-type">MyInterface</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 方法体</span><br>        println(<span class="hljs-string">&quot;bar&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c =  Child()<br>    c.foo();<br>    c.bar();<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h2><p>接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口是，必须重写属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&#123;<br>  <span class="hljs-keyword">var</span> name:String <span class="hljs-comment">// name属性，抽象</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImpl</span>:<span class="hljs-type">MyInterface</span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> name:String = <span class="hljs-string">&quot;paulniu&quot;</span>  <span class="hljs-comment">// 重写属性</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">var</span> name:String <span class="hljs-comment">//name 属性, 抽象的</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 可选的方法体</span><br>        println(<span class="hljs-string">&quot;foo&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-type">MyInterface</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;runoob&quot;</span> <span class="hljs-comment">//重写属性</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 方法体</span><br>        println(<span class="hljs-string">&quot;bar&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c =  Child()<br>    c.foo();<br>    c.bar();<br>    println(c.name)<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="函数的重写"><a href="#函数的重写" class="headerlink" title="函数的重写"></a>函数的重写</h2><p>实现多个接口时，可能会遇到同一个方法继承多个实现类的问题，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123; print(<span class="hljs-string">&quot;A&quot;</span>) &#125;   <span class="hljs-comment">// 已实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>                  <span class="hljs-comment">// 未实现，没有方法体，是抽象的</span><br>&#125;<br> <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123; print(<span class="hljs-string">&quot;B&quot;</span>) &#125;   <span class="hljs-comment">// 已实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123; print(<span class="hljs-string">&quot;bar&quot;</span>) &#125; <span class="hljs-comment">// 已实现</span><br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-type">A</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123; print(<span class="hljs-string">&quot;bar&quot;</span>) &#125;   <span class="hljs-comment">// 重写</span><br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-type">A</span>, <span class="hljs-type">B</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>&lt;A&gt;.foo()<br>        <span class="hljs-keyword">super</span>&lt;B&gt;.foo()<br>    &#125;<br> <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>&lt;B&gt;.bar()<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> d =  D()<br>    d.foo();<br>    d.bar();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>示例中接口A和接口B都定义了foo()和bar()方法，两者都实现了foo()，B实现了bar()方法。因为C是一个实现了A的具体类，所以必须重写bar()并且实现这个抽象方法<br>然后如果我们从A和B派生D，我们需简要实现多个接口继承的所有方法，并且知名D应该如何实现他们。</p>
<h1 id="Kotlin的扩展"><a href="#Kotlin的扩展" class="headerlink" title="Kotlin的扩展"></a>Kotlin的扩展</h1><p>Kotlin可以对一个类的属性和方法进行扩展，且不需要继承或者使用Decorator模式<br>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响</p>
<h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>扩展函数可以在已有类中添加新方法，不会对原有类做出修改，扩展函数定义形式为</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> receiverType.<span class="hljs-title">functionName</span><span class="hljs-params">(params)</span></span>&#123;<br>  <span class="hljs-comment">// 方法的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>receiverType：表示函数的接收者，也就是函数的扩展的对象</li>
<li>functionName：扩展函数的名称</li>
<li>params：扩展函数的参数，可以是NULL</li>
</ul>
<p>一个小例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-keyword">var</span> name:String)<br><br><span class="hljs-comment">// 扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> User.<span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>  print(<span class="hljs-string">&quot;用户名是<span class="hljs-subst">$&#123;name&#125;</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> user = User(<span class="hljs-string">&quot;paulniu&quot;</span>)<br>  user.print()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个例子，为MutableList添加一个swap函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 扩展函数swap，调换不同位置的值</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> MutableList<span class="hljs-type">&lt;Int&gt;</span>.<span class="hljs-title">swap</span><span class="hljs-params">(index1:<span class="hljs-type">Int</span>,index2:<span class="hljs-type">Int</span>)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> tmp = <span class="hljs-keyword">this</span>[index1]<br>  <span class="hljs-keyword">this</span>[index1] = <span class="hljs-keyword">this</span>[index2]<br>  <span class="hljs-keyword">this</span>[index2] = tmp<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> l = mutableListOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>  l.swap(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br>  println(l.toString())<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>this关键字指代接收者对象</p>
</blockquote>
<p>扩展函数是静态解析的<br>扩展函数是静态解析的，并不是接受这类型的虚拟成员，在调用扩展函数时，具体被调用的是哪一个函数，有调用函数的对象表达式来决定，而不是动态的类型决定的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>:<span class="hljs-type">C</span>()<br><span class="hljs-function"><span class="hljs-keyword">fun</span> c.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> D.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printFoo</span><span class="hljs-params">(c:<span class="hljs-type">C</span>)</span></span>&#123;<br>  println(c.foo())<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  printFoo(D())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果扩展函数和成员函数一直，则使用该函数时，会优先使用成员函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;成员函数&quot;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> C.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>  println(<span class="hljs-string">&quot;扩展函数&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> c = C();<br>  c.foo();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>输出结果是成员函数</p>
</blockquote>
<h2 id="扩展一个空对象"><a href="#扩展一个空对象" class="headerlink" title="扩展一个空对象"></a>扩展一个空对象</h2><p>在扩展函数内，可以通过this来判断接受者是否为NULL，这样即使接收者为NULL，也是可以调用扩展函数的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Any?.<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>:String&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null&quot;</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> toString()<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> t = <span class="hljs-literal">null</span><br>  println(t.toString())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>扩展属性<br>除了函数，Kotlin也支持属性对属性进行扩展</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">val <span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>List<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>.lastIndex:Int</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  get() = size - 1</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure>
<p>扩展属性允许定义在类或者Kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段，所以不允许被初始化，只能由现实提供的getter&#x2F;setter定义</p>
<blockquote>
<p>扩展属性只能被声明为val</p>
</blockquote>
<h2 id="伴生对象的扩展"><a href="#伴生对象的扩展" class="headerlink" title="伴生对象的扩展"></a>伴生对象的扩展</h2><p>如果一个类定义有一个伴生对象，我们可以对伴生对象定义扩展函数和属性<br>伴生对象通过”类名.”的形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>    <span class="hljs-comment">// 将被称为&quot;Companion&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> MyClass.Companion.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>  println(<span class="hljs-string">&quot;伴随对象的扩展函数&quot;</span>)<br>&#125;<br><span class="hljs-keyword">val</span> MyClass.Companion.no:<span class="hljs-built_in">Int</span><br>  <span class="hljs-keyword">get</span>() = <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  println(<span class="hljs-string">&quot;no:<span class="hljs-subst">$&#123;MyClass.no&#125;</span>&quot;</span>)<br>  MyClass.foo()<br>&#125;  <br></code></pre></td></tr></table></figure>

<h2 id="扩展的作用域"><a href="#扩展的作用域" class="headerlink" title="扩展的作用域"></a>扩展的作用域</h2><p>通常扩展函数或属性定义在顶级包下，要使用所定义包之外的一个扩展，通过import导入扩展的函数名进行使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.expamle.paulniu<br><br><span class="hljs-keyword">import</span> foo.bar.goo <span class="hljs-comment">// 导入所有名为goo的扩展</span><br><span class="hljs-keyword">import</span> foo.bar.*   <span class="hljs-comment">// 从foo.bar导入一切</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">usage</span><span class="hljs-params">(baz:<span class="hljs-type">Baz</span>)</span></span>&#123;<br>  baz.goo()<br>&#125;<br><br><br><span class="hljs-keyword">package</span> foo.bar<br><span class="hljs-function"><span class="hljs-keyword">fun</span> Baz.<span class="hljs-title">goo</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="扩展声明为成员"><a href="#扩展声明为成员" class="headerlink" title="扩展声明为成员"></a>扩展声明为成员</h2><p>在一个类内部我们可以为另一个类声明扩展<br>在这个扩展中，有多个隐含的接受者，其中扩展方法定义所在的类的实例称为分发接受者，而扩展方法的目标类型的实例被称为扩展接受者</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;D bar&quot;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">baz</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;C baz&quot;</span>)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> D.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>    bar()<br>    baz()<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">caller</span><span class="hljs-params">(d:<span class="hljs-type">D</span>)</span></span>&#123;<br>    d.foo()<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> c:C = C()<br>  <span class="hljs-keyword">val</span> d:D = D()<br>  c.caller(d)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在C类内，创建D类的扩展，此时C被称为分发接受者，而D为扩展接受者，在扩展函数中，可以调用派发接受者的成员函数<br>加入在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接受者优先，要引用分发接受者的成员可以使用this的指定语法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123; println(<span class="hljs-string">&quot;D bar&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123; println(<span class="hljs-string">&quot;C bar&quot;</span>) &#125;  <span class="hljs-comment">// 与 D 类 的 bar 同名</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> D.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>        bar()         <span class="hljs-comment">// 调用 D.bar()，扩展接收者优先</span><br>        <span class="hljs-keyword">this</span><span class="hljs-symbol">@C</span>.bar()  <span class="hljs-comment">// 调用 C.bar()</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">caller</span><span class="hljs-params">(d: <span class="hljs-type">D</span>)</span></span> &#123;<br>        d.foo()   <span class="hljs-comment">// 调用扩展函数</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c: C = C()<br>    <span class="hljs-keyword">val</span> d: D = D()<br>    c.caller(d)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以成员的形式定义的扩展函数，可以生命为open，而且可以在子类中覆盖，也就是说，在这类扩展函数的派发过程中，针对分发接受者是虚拟的，但针对扩展接受者仍然是静态的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D1</span> : <span class="hljs-type">D</span>() &#123;<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> D.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;D.foo in C&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> D1.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;D1.foo in C&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">caller</span><span class="hljs-params">(d: <span class="hljs-type">D</span>)</span></span> &#123;<br>        d.foo()   <span class="hljs-comment">// 调用扩展函数</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span> : <span class="hljs-type">C</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> D.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;D.foo in C1&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> D1.<span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;D1.foo in C1&quot;</span>)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    C().caller(D())   <span class="hljs-comment">// 输出 &quot;D.foo in C&quot;</span><br>    C1().caller(D())  <span class="hljs-comment">// 输出 &quot;D.foo in C1&quot; —— 分发接收者虚拟解析</span><br>    C().caller(D1())  <span class="hljs-comment">// 输出 &quot;D.foo in C&quot; —— 扩展接收者静态解析</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Kotlin数据类和密封类"><a href="#Kotlin数据类和密封类" class="headerlink" title="Kotlin数据类和密封类"></a>Kotlin数据类和密封类</h1><h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>Kotlin可以创建一个只包含数据的类，关键字为data</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">data <span class="hljs-keyword">class</span> <span class="hljs-symbol">User</span>(<span class="hljs-symbol">val</span> <span class="hljs-symbol">name:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">val</span></span> <span class="hljs-symbol">age:<span class="hljs-symbol">Int</span></span>)<br></code></pre></td></tr></table></figure>
<p>编译器会自动的从主构造函数中根据所声明的属性提取一下函数</p>
<ul>
<li>equals()&#x2F;hashCode()</li>
<li>toString()  格式如”User(name&#x3D;paulniu,age&#x3D;18)”</li>
<li>componentN() functions对应于属性，按声明顺序排列</li>
<li>copy() 函数<br>如果这些函数再累中已经被明确定义了，或者从超类中继承而来，就不会再生成<br>为了保证生成代码的一致性以及有意义，数据类需要满足一下几个条件</li>
</ul>
<ol>
<li>主构造函数至少包含一个参数</li>
<li>所有的主构造函数的参数必须标识为val或者var</li>
<li>数据类型不可以声明为abstract，open，sealed或者inner</li>
<li>数据类不能继承其他类(但可以实现接口)</li>
</ol>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>复制使用copy函数，我们可以使用该函数复制对象并修改部分属性，例如上面的User类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(name:<span class="hljs-type">String</span>=this.name,age:<span class="hljs-type">Int</span>=this.age)</span></span> = User(name,age)<br></code></pre></td></tr></table></figure>
<p>举个例子</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">data <span class="hljs-keyword">class</span> <span class="hljs-symbol">User</span>(<span class="hljs-symbol">val</span> <span class="hljs-symbol">name:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">val</span></span> <span class="hljs-symbol">age:<span class="hljs-symbol">Int</span></span>)<br><span class="hljs-symbol">fun</span> <span class="hljs-symbol">main</span>(<span class="hljs-symbol">args:<span class="hljs-symbol">Array</span></span>&lt;<span class="hljs-symbol">String</span>&gt;)&#123;<br>  val jack = User(name = <span class="hljs-string">&quot;Jack&quot;</span>,age = <span class="hljs-number">1</span>)<br>  val olderJack = jack.copy(age = <span class="hljs-number">2</span>)<br>  println(jack)<br>  println(olderJack)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>密封类用来表示受限的类继承结构：当一个值为有限几种的类型，而不能有任何其他类型时，在某种意义上，他们是枚举类的扩展，枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有包含状态的多个实例，声明一个密封类使用sealed修饰类，密封类可以有子类，但是所有子类必须要内嵌到密封类中<br>sealed不能修饰interface，abstract class</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">sealed <span class="hljs-keyword">class</span> <span class="hljs-symbol">Expr</span><br><span class="hljs-symbol">data</span> <span class="hljs-symbol">class</span> <span class="hljs-symbol">Const</span>(<span class="hljs-symbol">val</span> <span class="hljs-symbol">number: <span class="hljs-symbol">Double</span></span>) : <span class="hljs-symbol">Expr</span>()<br><span class="hljs-symbol">data</span> <span class="hljs-symbol">class</span> <span class="hljs-symbol">Sum</span>(<span class="hljs-symbol">val</span> <span class="hljs-symbol">e1: <span class="hljs-symbol">Expr</span>, <span class="hljs-symbol">val</span></span> <span class="hljs-symbol">e2: <span class="hljs-symbol">Expr</span></span>) : <span class="hljs-symbol">Expr</span>()<br><span class="hljs-symbol">object</span> <span class="hljs-symbol">NotANumber</span> : <span class="hljs-symbol">Expr</span>()<br><br><span class="hljs-symbol">fun</span> <span class="hljs-symbol">eval</span>(<span class="hljs-symbol">expr: <span class="hljs-symbol">Expr</span></span>): <span class="hljs-symbol">Double</span> = <span class="hljs-symbol">when</span> (<span class="hljs-symbol">expr</span>) &#123;<br>    <span class="hljs-keyword">is</span> Const -&gt; expr.number<br>    <span class="hljs-keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)<br>    NotANumber -&gt; Double.NaN<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用密封类的关键好处在于使用when表达式的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句在添加一个else子语句了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eval</span><span class="hljs-params">(expr: <span class="hljs-type">Expr</span>)</span></span>: <span class="hljs-built_in">Double</span> = <span class="hljs-keyword">when</span>(expr) &#123;<br>    <span class="hljs-keyword">is</span> Expr.Const -&gt; expr.number<br>    <span class="hljs-keyword">is</span> Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2)<br>    Expr.NotANumber -&gt; <span class="hljs-built_in">Double</span>.NaN<br>    <span class="hljs-comment">// 不再需要 `else` 子句，因为我们已经覆盖了所有的情况</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Kotlin泛型"><a href="#Kotlin泛型" class="headerlink" title="Kotlin泛型"></a>Kotlin泛型</h1><p>泛型，即参数化类型，将类型参数化，可以用在类，接口，方法上<br>与java一样，Kotlin也提供了泛型，为类型安全提供了保证，消除类型强转的烦恼</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Box</span>&lt;<span class="hljs-symbol">T</span>&gt;(<span class="hljs-symbol">t:<span class="hljs-symbol">T</span></span>)&#123;<br>  var value = t<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建类的实例时我们需要制定类型参数</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">val <span class="hljs-type">box</span>:<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt; = <span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt;(<span class="hljs-number">1</span>)<br>// 或者<br>val <span class="hljs-type">box</span> = Box(<span class="hljs-number">1</span>)  // 编译器会进行类型推断，<span class="hljs-number">1</span>类型为<span class="hljs-type">Int</span>，所以编译器知道哦我们要使用的是<span class="hljs-type">Box</span>&lt;<span class="hljs-type">Int</span>&gt;<br></code></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-type">T</span>&gt;(t : T) &#123;<br>    <span class="hljs-keyword">var</span> value = t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> boxInt = Box&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">var</span> boxString = Box&lt;String&gt;(<span class="hljs-string">&quot;Runoob&quot;</span>)<br><br>    println(boxInt.value)<br>    println(boxString.value)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义泛型类型变量可以完整的写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数<br>Kotlin泛型函数的声明与Java相同，类型参数主要放在函数名的前面<br>在调用泛型函数时，如果可以推断出类型参数，可以直接省略泛型类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> age = <span class="hljs-number">23</span><br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;runoob&quot;</span><br>    <span class="hljs-keyword">val</span> bool = <span class="hljs-literal">true</span><br><br>    doPrintln(age)    <span class="hljs-comment">// 整型</span><br>    doPrintln(name)   <span class="hljs-comment">// 字符串</span><br>    doPrintln(bool)   <span class="hljs-comment">// 布尔型</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">doPrintln</span><span class="hljs-params">(content: <span class="hljs-type">T</span>)</span></span> &#123;<br><br>    <span class="hljs-keyword">when</span> (content) &#123;<br>        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; println(<span class="hljs-string">&quot;整型数字为 <span class="hljs-variable">$content</span>&quot;</span>)<br>        <span class="hljs-keyword">is</span> String -&gt; println(<span class="hljs-string">&quot;字符串转换为大写：<span class="hljs-subst">$&#123;content.toUpperCase()&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;T 不是整型，也不是字符串&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>我们可以使用泛型约束来设定一个给定参数允许使用的类型<br>Kotlin中使用：对泛型的类型上限进行约束<br>最常见的约束是上界</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T:Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">sort</span><span class="hljs-params">(list:<span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中comparable的子类型可以替换T</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">sort(listOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))  // <span class="hljs-built_in">Int</span>类型是Comparable&lt;<span class="hljs-built_in">Int</span>&gt;的子类型<br>sort(listOf(HashMap&lt;<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">String</span>&gt;()))  // 错误，HashMap&lt;<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">String</span>&gt;不是Comparable&lt;HashMap&lt;<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">String</span>&gt;&gt;的子类型<br></code></pre></td></tr></table></figure>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">copyWhenGreater</span><span class="hljs-params">(list:<span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;,threshold:<span class="hljs-type">T</span>)</span></span>:List&lt;String&gt;<br>  <span class="hljs-keyword">where</span> T:CharSequence,<br>        T:Comparable&lt;T&gt;&#123;<br>          <span class="hljs-keyword">return</span> list.filter&#123;<br>            it &gt; threshold<br>          &#125;.map&#123;<br>            it.toString()<br>          &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<h3 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h3><p>Kotlin中没有通配符类型，他有两个其他类型的东西，声明处型变与类型投影</p>
<h4 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h4><p>声明处的类型变异使用协变注解修饰符：in，out，消费者in，生产者out<br>使用out使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但无法作为入参的类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义一个支持协变的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">out A</span>&gt;(<span class="hljs-keyword">val</span> a:A)&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>:A&#123;<br>    <span class="hljs-keyword">return</span> a<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> strCo:MyClass&lt;String&gt; = MyClass(<span class="hljs-string">&quot;paulniu&quot;</span>)<br>  <span class="hljs-keyword">var</span> anyCo:MyClass&lt;Any&gt; = MyClass&lt;Any&gt;(<span class="hljs-string">&quot;bbbbbb&quot;</span>)<br>  anyCo = strCo<br>  println(anyCo.foo())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>in使得一个类型参数逆变，逆变类型参数只能作为输入，可以作为入参的类型但无法作为返回值类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">in A</span>&gt;(a:A)&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(a:<span class="hljs-type">A</span>)</span></span>&#123;<br><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> strDCo = MyClass(<span class="hljs-string">&quot;aaaaaa&quot;</span>)<br>  <span class="hljs-keyword">var</span> anyDCo = MyClass&lt;Any&gt;(<span class="hljs-string">&quot;bbbbbbb&quot;</span>)<br>  strDCo = anDCo<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="星号投射"><a href="#星号投射" class="headerlink" title="星号投射"></a>星号投射</h2><p>有些时候，我们想要表示刚开始并不知道类型参数的任何信息，但仍然希望能够安全的使用他，这里所谓的安全使用是指，对泛型类型定义一个类型投射，要求这个泛型类型的所有实体实例，都是这个投射的子类型</p>
<ul>
<li>假如类型定义为Foo<out T>,其中T是一个协变的类型参数，上界为TUpper，Foo&lt;&gt;等价于Foo<out TUpper> ,它表示当T未知时，我们可以安全的从Foo&lt;&gt;中读取TUpper类型的值</li>
<li>假如类型定义为Foo(in T),其中T是一个反向协变的类型参数，Foo&lt;&gt;等价于Foo<inNothing>,它表示，当T未知时，我们不能安全的向Foo&lt;&gt;写入任何东西</li>
<li>假如类型定义为Foo<T>,其中T是一个协变的类型参数，上界为TUpper，对于读取值的场合，Foo&lt;*&gt;等价于Foo<out TUpper>，对于写入值的场合，等价于Foo<in Nothing></li>
</ul>
<p>如果一个泛型类型中存在多个类型参数，那么每个类型参数都可以单独投射，比如，如果定义类型为interface Function&lt;in T,out U&gt;,那么可以出现以下几种星号投射</p>
<ol>
<li>Function&lt;*,String&gt;  代表Function&lt;in Nothing,String&gt;</li>
<li>Function&lt;Int,*&gt;     代表Function&lt;Int,out Any?&gt;</li>
<li>function&lt;, &gt;        代表Function&lt;in Nothing,out Any?&gt;</li>
</ol>
<blockquote>
<p>注意：星号投射与Java的原生类型非常类似，但可以安全使用<br>其实我们可以认为*代指了所有类型，相当于Any?</p>
</blockquote>
<p>举个例子</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>&lt;<span class="hljs-symbol">T</span>&gt;(<span class="hljs-symbol">val</span> <span class="hljs-symbol">t:<span class="hljs-symbol">T</span>,<span class="hljs-symbol">val</span></span> <span class="hljs-symbol">t2:<span class="hljs-symbol">T</span>,<span class="hljs-symbol">val</span></span> <span class="hljs-symbol">t3:<span class="hljs-symbol">T</span></span>)<br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Apple</span>(<span class="hljs-symbol">var</span> <span class="hljs-symbol">name:<span class="hljs-symbol">String</span></span>)<br><span class="hljs-symbol">fun</span> <span class="hljs-symbol">main</span>(<span class="hljs-symbol">args:<span class="hljs-symbol">Array</span></span>&lt;<span class="hljs-symbol">String</span>&gt;)&#123;<br>  <span class="hljs-comment">// 使用类</span><br>  val a1:A&lt;*&gt; = A(<span class="hljs-number">12</span>,<span class="hljs-string">&quot;String&quot;</span>,Apple(<span class="hljs-string">&quot;苹果&quot;</span>))<br>  val a2:a&lt;Any?&gt; = A(<span class="hljs-number">13</span>,<span class="hljs-string">&quot;String&quot;</span>,Apple(<span class="hljs-string">&quot;苹果2&quot;</span>))<br>  val apple = a1.t3<br>  println(apple)<br>  val apple2 = apple as Apple <span class="hljs-comment">/// 强转为Apple类型</span><br>  println(apple2.name)<br>  <span class="hljs-comment">// 使用数组</span><br>  val lists:ArrayList&lt;*&gt; = <span class="hljs-built_in">array</span>ListOf(<span class="hljs-string">&quot;String&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1.2f</span>,Apple(<span class="hljs-string">&quot;苹果&quot;</span>))<br>  <span class="hljs-keyword">for</span>(item <span class="hljs-keyword">in</span> l)&#123;<br>    println(item)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Kotlin枚举类"><a href="#Kotlin枚举类" class="headerlink" title="Kotlin枚举类"></a>Kotlin枚举类</h1><p>枚举类最基本的用法是实现了一个类型安全的枚举<br>枚举常量用逗号分隔，每个枚举常量都是一个对象</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Color</span>&#123;<br>  RED,BLACK,BLUE,GREEN,WHITE<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="枚举初始化"><a href="#枚举初始化" class="headerlink" title="枚举初始化"></a>枚举初始化</h2><p>每一个枚举都是枚举类的实例，他们可以被初始化</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">enum class <span class="hljs-attribute">Color</span>(val rgb:Int)&#123;<br>  <span class="hljs-built_in">RED</span>(<span class="hljs-number">0</span>xFF0000),<br>  <span class="hljs-built_in">GREEN</span>(<span class="hljs-number">0</span>x00FF00),<br>  <span class="hljs-built_in">BLUE</span>(<span class="hljs-number">0</span>x0000FF)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>默认名称为枚举字符名，值从0开始，若需要指定值，则可以使用其构造函数</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Shape</span>(<span class="hljs-symbol">value:<span class="hljs-symbol">Int</span></span>)&#123;<br>  ovel(<span class="hljs-number">100</span>),<br>  rectangle(<span class="hljs-number">200</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>枚举还支持以声明自己的匿名类及相应的方法，以及覆盖基类的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtocolState</span>&#123;<br>  WAITING&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span> = TALKING<br>  &#125;,<br>  TALKING&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span> = WAITING<br>  &#125;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>:ProtocolState<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果枚举定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开</p>
<h2 id="常用枚举常量"><a href="#常用枚举常量" class="headerlink" title="常用枚举常量"></a>常用枚举常量</h2><p>Kotlin中的枚举类具有合成方法，允许遍历定义的枚举常量，并通过其名称获取枚举常数</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EnumClass</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">value</span>:String)</span>:EnumClass  <span class="hljs-comment">// 转换置顶那么为枚举类，若未匹配成功，则会抛出IllegalArgumentException</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EnumClass</span>.</span></span>values<span class="hljs-literal">()</span>:Array&lt;EnumClass&gt;        <span class="hljs-comment">// 以数组的形式返回枚举值</span><br></code></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">enum class <span class="hljs-attribute">Color</span>&#123;<br>  RED,BLACK,BLUE,GREEN,WHITE<br>&#125;<br>fun <span class="hljs-selector-tag">main</span>(args:Array&lt;String&gt;)&#123;<br>  <span class="hljs-selector-tag">var</span> <span class="hljs-attribute">color</span>:Color = Color.BLUE<br><br>  <span class="hljs-built_in">println</span>(Color.<span class="hljs-built_in">values</span>())<br>  <span class="hljs-built_in">println</span>(Color.<span class="hljs-built_in">valueOf</span>(<span class="hljs-string">&quot;RED&quot;</span>))<br>  <span class="hljs-built_in">println</span>(color.name)<br>  <span class="hljs-built_in">println</span>(color.ordinal)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同时我们可以使用enumValues<T>()和enumValueOf<T>()函数以泛型的方式访问枚举类中的常量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RGB</span> &#123; RED, GREEN, BLUE &#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Enum&lt;T&gt;</span>&gt; <span class="hljs-title">printAllValues</span><span class="hljs-params">()</span></span> &#123;<br>    print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    printAllValues&lt;RGB&gt;() <span class="hljs-comment">// 输出 RED, GREEN, BLUE</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="Kotlin对象表达式和对象声明"><a href="#Kotlin对象表达式和对象声明" class="headerlink" title="Kotlin对象表达式和对象声明"></a>Kotlin对象表达式和对象声明</h1><p>Kotlin用对象表达式和对象象声明来实现创建一个对某个类做了轻微改动的类的对象，且不需要去声明一个新的子类</p>
<h2 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h2><p>通过对象表达式实现一个匿名内部类的对象用于方法的参数中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">window.addMouseListener(<span class="hljs-keyword">object</span>:MouseAdapter()&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mouseClicked</span><span class="hljs-params">(e:<span class="hljs-type">MouseEvent</span>)</span></span>&#123;<br>    <span class="hljs-comment">//</span><br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mouseEntered</span><span class="hljs-params">(e:<span class="hljs-type">MouseEvent</span>)</span></span>&#123;<br><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>对象可以继承于某个基类，或者实现其他接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(x:<span class="hljs-built_in">Int</span>)&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> y:<span class="hljs-built_in">Int</span> = x<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span>&#123;<br><br>&#125;<br><span class="hljs-keyword">val</span> ab:A = <span class="hljs-keyword">object</span>:A(<span class="hljs-number">1</span>) ,B&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> y = <span class="hljs-number">15</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果超类型有一个构造函数，则必须传递参数给它。多个超类型和接口可以用逗号分隔<br>通过对象表达式可以越过类的定义直接得到一个对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> site = <span class="hljs-keyword">object</span>&#123;<br>    <span class="hljs-keyword">var</span> name:String = <span class="hljs-string">&quot;paulniu&quot;</span><br>    <span class="hljs-keyword">var</span> url:String = <span class="hljs-string">&quot;www.paulniu.com&quot;</span><br>  &#125;<br>  println(site.name)<br>  println(site.url)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>请注意，匿名对象可以用作只在本地和私有作用域中声明的类型，如果你是用匿名对象最为公有函数的返回类型或者用作共有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是Any，在匿名对象中添加的成员将无法访问</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123;<br>  <span class="hljs-comment">// 私有函数，所以其返回类型是匿名对象类型</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span>&#123;<br>    <span class="hljs-keyword">val</span> x:String = <span class="hljs-string">&quot;x&quot;</span><br>  &#125;<br>  <span class="hljs-comment">// 公有函数，所以其返回类型是Any</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">publicFoo</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span>&#123;<br>    <span class="hljs-keyword">val</span> x:String = <span class="hljs-string">&quot;y&quot;</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> x1 = foo().x         <span class="hljs-comment">// 没有问题</span><br>    <span class="hljs-keyword">val</span> x2 = publicFoo().x   <span class="hljs-comment">// 报错，未能解析的引用x</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在对象表达式中可以方便的访问到作用域中的其他变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">countClicks</span><span class="hljs-params">(window:<span class="hljs-type">JComponent</span>)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> clickCount = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> enterCount = <span class="hljs-number">0</span><br>  window.addMouseListener(<span class="hljs-keyword">object</span>:MouseAdapter()&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mouseClicked</span><span class="hljs-params">(e:<span class="hljs-type">MouseEvent</span>)</span></span>&#123;<br>      clickCount++<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mouseEntered</span><span class="hljs-params">(e:<span class="hljs-type">MouseEvent</span>)</span></span>&#123;<br>      enterCount++<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h2><p>Kotlin使用object关键字来声明一个对象<br>Kotlin中我们可以方便的通过对象声明来获取一个单例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> DataProviderManager&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">registerDataProvider</span><span class="hljs-params">(provider:<span class="hljs-type">DataProvider</span>)</span></span>&#123;<br>    <span class="hljs-comment">//</span><br>  &#125;<br>  <span class="hljs-keyword">val</span> allDataProviders:Collection&lt;DataProvider&gt;<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>引用该对象，我们直接使用其名称即可</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DataProviderManager</span>.</span></span>register<span class="hljs-constructor">DataProvider(<span class="hljs-operator">...</span>)</span><br></code></pre></td></tr></table></figure>
<p>当然我们可以定义一个变量来获取这个对象，当我们定义两个不同的变量来获取一个对象的时候，我们并不能得到两个不同的变量，也就是说通过这种方式，我们其实实现的是单例</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> data1 = DataProviderManager<br><span class="hljs-selector-tag">var</span> data2 = DataProviderManager<br>data1<span class="hljs-selector-class">.name</span> = <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;data1 name is $&#123;data2.name&#125;&quot;</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> Site&#123;<br>  <span class="hljs-keyword">var</span> url:String = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-keyword">val</span> name:String = <span class="hljs-string">&quot;个人测试&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> s1 = Site<br>  <span class="hljs-keyword">var</span> s2 = Site<br>  s1.url = <span class="hljs-string">&quot;www.paulniu.com&quot;</span><br>  println(s1.url)<br>  println(s2.url)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对象可以有超类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> DefaultListener:MouseAdapter()&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mouseClicked</span><span class="hljs-params">(e:<span class="hljs-type">MouseEvnet</span>)</span></span>&#123;<br>    <span class="hljs-comment">//</span><br>  &#125;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mouseEntered</span><span class="hljs-params">(e:<span class="hljs-type">MouseEvent</span>)</span></span>&#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Site</span>&#123;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;paulniu&quot;</span><br>  <span class="hljs-keyword">object</span> DestTop&#123;<br>    <span class="hljs-keyword">var</span> url =<span class="hljs-string">&quot;www.paulniu.com&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showName</span><span class="hljs-params">()</span></span>&#123;<br>      println&#123;<span class="hljs-string">&quot;desk legs <span class="hljs-variable">$name</span>&quot;</span>&#125;  <span class="hljs-comment">// 这样写是错误的，不能访问到外部类的方法和名称</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">var</span> site = Site()<br>  site.DestTop.url  <span class="hljs-comment">// 错误写法，不能通过外部类的实例访问到该对象</span><br>  Site.DestTop.url  <span class="hljs-comment">// 正确写法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>类内部的对象声明可以用companyion关键字标记，这样他就可以与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Factory&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>:MyClass = MyClass()<br>  &#125;<br>&#125;<br><span class="hljs-keyword">val</span> instance = MyClass.create()   <span class="hljs-comment">// 访问到对象的内部元素</span><br></code></pre></td></tr></table></figure>
<p>我们可以省略掉该对象的对象名，然后使用Companion替代需要声明的对象名</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>    <span class="hljs-comment">// </span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：一个类中只能声明一个内部关联对象，即关键字companion只能使用一次</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Factory</span>&lt;<span class="hljs-type">T</span>&gt;&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span> :T<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>:Factory&lt;MyClass&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>:MyClass = MyClass()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对象表达式和对象声明之间的语义差异</p>
<ul>
<li>对象表达式是在使用他们的地方立即执行的</li>
<li>对象声明是在第一次被访问到时延迟初始化</li>
<li>伴生对象的初始化是在相应的类被加载(解析)时，与java静态初始化器的语义相匹配</li>
</ul>
<h1 id="Kotlin委托"><a href="#Kotlin委托" class="headerlink" title="Kotlin委托"></a>Kotlin委托</h1><p>委托模式是软件设计模式中一项基本技巧，在委托模式中，有两个对象参与处理同一个请求，接收请求的对象将请求委托给另一个对象来处理<br>Kotlin直接支持委托模式，通过关键字by实现委托</p>
<h2 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h2><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在这个示例中，派生类Derived继承了接口Base的所有方法，并且委托一个传入的Base类的对象来执行这些方法</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Base</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br>&#125;<br><span class="hljs-comment">// 实现接口的被委托的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseImpl</span>(<span class="hljs-keyword">val</span> x:<span class="hljs-built_in">Int</span>):Base&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>    print(x)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 通过关键字by建立委托类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>(b:Base):Base <span class="hljs-keyword">by</span> b<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> b = BaseImpl(<span class="hljs-number">10</span>)<br>  Derived(b).print()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Derived声明中，by子句表示，将b保存在Derived的对象实例内部，而且编译器将会生继承自Base接口的所有方法，并将调用转发给b</p>
<h2 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h2><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">val/var <span class="hljs-tag">&lt;<span class="hljs-name">属性名</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">类型</span>&gt;</span> by <span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>var&#x2F;val:属性类型(可变&#x2F;只读)</li>
<li>属性名:属性名称</li>
<li>类型:属性的数据类型</li>
<li>表达式:委托代理类</li>
</ol>
<p>by关键字之后的表达式就是委托，属性的get()方法(以及set()方法)将委托给这个对象的getValue()和setValue()方法。属性委托不必实现任何接口，但必须提供getValue()函数(var属性，还需要setValue()函数)</p>
<h3 id="定义一个被委托的类"><a href="#定义一个被委托的类" class="headerlink" title="定义一个被委托的类"></a>定义一个被委托的类</h3><p>该类需要包含getValue()方法和setValue方法，且参数thisRef为进行委托的类的对象，prop为进行委托的属性的对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlin.reflect.KProperty<br><span class="hljs-comment">// 定义包含属性委托的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>&#123;<br>  <span class="hljs-keyword">var</span> p:String <span class="hljs-keyword">by</span> Delegate()<br>&#125;<br><span class="hljs-comment">// 委托的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegate</span>&#123;<br>  <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef:<span class="hljs-type">Any</span>?,property:<span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>:String&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$thisRef</span>,这里委托了 <span class="hljs-subst">$&#123;property.name&#125;</span> 属性&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef:<span class="hljs-type">Any</span>?,property:<span class="hljs-type">KProperty</span>&lt;*&gt; ,value:<span class="hljs-type">String</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$thisRef</span>的<span class="hljs-subst">$&#123;property.name&#125;</span>属性赋值为<span class="hljs-variable">$value</span>&quot;</span><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> e = Example()<br>  println(e.p)     <span class="hljs-comment">// 访问该属性，调用getValue()函数</span><br><br>  e.p = <span class="hljs-string">&quot;paulniu&quot;</span>  <span class="hljs-comment">// 调用setValue函数</span><br>  println(e.p)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h2><p>Kotlin的标准库中已经内置了很多工厂方法来实现属性的委托</p>
<h3 id="延迟属性Lazy"><a href="#延迟属性Lazy" class="headerlink" title="延迟属性Lazy"></a>延迟属性Lazy</h3><p>lazy()是一个函数，接受一个Lambda表达式作为参数，返回一个Lazy<T>实例的函数，返回的实例可以作为实现延迟属性的委托：第一次调用get()汇之星已传递给lazy()的lambda表达式并记录结果，后续调用get()只是返回记录的结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> lazyValue:String <span class="hljs-keyword">by</span> lazy&#123;<br>  println(<span class="hljs-string">&quot;computed&quot;</span>)<span class="hljs-comment">// 第一次调用时输出，第二次调用不执行</span><br>  <span class="hljs-string">&quot;hello&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  println(lazyValue) <span class="hljs-comment">// 第一次执行，执行两次输出表达式</span><br>  println(lazyValue) <span class="hljs-comment">// 第二次执行，只输出返回值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="可观察属性-Observable"><a href="#可观察属性-Observable" class="headerlink" title="可观察属性 Observable"></a>可观察属性 Observable</h3><p>Observable可以用于实现观察者模式<br>Delegates.observable()函数接收两个参数，第一个是初始化值，第二个是属性变化事件的响应器(handler)<br>在属性赋值后会执行事件的响应器,它由三个参数：被赋值的属性，旧值和新值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlin.properties.Delegates<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>  <span class="hljs-keyword">var</span> name:String <span class="hljs-keyword">by</span> Delegates.observable(<span class="hljs-string">&quot;初始值&quot;</span>)&#123;<br>    prop,old,new -&gt;<br>    println(<span class="hljs-string">&quot;旧值：<span class="hljs-variable">$old</span> -&gt; 新值：<span class="hljs-variable">$new</span>&quot;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;<br>  <span class="hljs-keyword">val</span> user = User()<br>  user.name = <span class="hljs-string">&quot;第一次赋值&quot;</span><br>  user.name = <span class="hljs-string">&quot;第二次赋值&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="把属性存储在映射中"><a href="#把属性存储在映射中" class="headerlink" title="把属性存储在映射中"></a>把属性存储在映射中</h3><p>一个常见的用例是在一个映射map里存储属性的值，这经常出现在像解析JSON或者其他”动态”事情的应用中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Site</span>(<span class="hljs-keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;<br>    <span class="hljs-keyword">val</span> name: String <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">val</span> url: String  <span class="hljs-keyword">by</span> map<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-comment">// 构造函数接受一个映射参数</span><br>    <span class="hljs-keyword">val</span> site = Site(mapOf(<br>        <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;菜鸟教程&quot;</span>,<br>        <span class="hljs-string">&quot;url&quot;</span>  to <span class="hljs-string">&quot;www.runoob.com&quot;</span><br>    ))<br>    <br>    <span class="hljs-comment">// 读取映射值</span><br>    println(site.name)<br>    println(site.url)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用var属性，需要把Map换成MutableMap</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Site</span>(val <span class="hljs-built_in">map</span>: MutableMap&lt;<span class="hljs-built_in">String</span>, Any?&gt;) &#123;<br>    val name: <span class="hljs-built_in">String</span> by <span class="hljs-built_in">map</span><br>    val url: <span class="hljs-built_in">String</span> by <span class="hljs-built_in">map</span><br>&#125;<br><br>fun <span class="hljs-title function_">main</span>(args: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">String</span>&gt;) &#123;<br><br>    var <span class="hljs-built_in">map</span>:MutableMap&lt;<span class="hljs-built_in">String</span>, Any?&gt; = <span class="hljs-title function_">mutableMapOf</span>(<br>            <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;菜鸟教程&quot;</span>,<br>            <span class="hljs-string">&quot;url&quot;</span> to <span class="hljs-string">&quot;www.runoob.com&quot;</span><br>    )<br><br>    val site = <span class="hljs-title function_">Site</span>(<span class="hljs-built_in">map</span>)<br><br>    <span class="hljs-built_in">println</span>(site.<span class="hljs-property">name</span>)<br>    <span class="hljs-built_in">println</span>(site.<span class="hljs-property">url</span>)<br><br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;--------------&quot;</span>)<br>    <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Google&quot;</span>)<br>    <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;www.google.com&quot;</span>)<br><br>    <span class="hljs-built_in">println</span>(site.<span class="hljs-property">name</span>)<br>    <span class="hljs-built_in">println</span>(site.<span class="hljs-property">url</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Not-Null"><a href="#Not-Null" class="headerlink" title="Not Null"></a>Not Null</h3><p>notNull适用于那些无法在初始化阶段就确定属性值的场合</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br>  <span class="hljs-keyword">var</span> notNullBar:<span class="hljs-built_in">String</span> <span class="hljs-keyword">by</span> Delegates.notNull&lt;<span class="hljs-built_in">String</span>&gt;()<br>&#125;<br>foo.notNullBar = <span class="hljs-string">&quot;bar&quot;</span><br>println(foo.notNullBar)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果属性在赋值前就被访问则会抛出异常</p>
</blockquote>
<h3 id="局部委托属性"><a href="#局部委托属性" class="headerlink" title="局部委托属性"></a>局部委托属性</h3><p>我们可以将局部变量生命成委托属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(computeFoo: () -&gt; <span class="hljs-type">Foo</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> memoizedFoo <span class="hljs-keyword">by</span> lazy(computeFoo)<br><br>    <span class="hljs-keyword">if</span> (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;<br>        memoizedFoo.doSomething()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p>
</blockquote>
<h4 id="属性委托要求"><a href="#属性委托要求" class="headerlink" title="属性委托要求"></a>属性委托要求</h4><p>对于只读属性(val属性)，他的委托必须提供一个名为getValue的函数，该函数接收一下参数：</p>
<ol>
<li>thisRef—必须与属性所有者类型(对于扩展属性—指被扩展的类型)相同或者是他的超类</li>
<li>property—必须是类型KProperty&lt;*&gt;或者其超类</li>
</ol>
<p>这个函数必须返回与属性相同的类型(或者子类)<br>对于一个值可变(mutable)属性(var属性),除了getValue函数之外，他的委托还必须另外再提供一个名为setValue的函数,接收一下参数</p>
<ol>
<li>property—必须是类型KProperty&lt;*&gt;或其超类</li>
<li>new value—必须和属性同类型或者是他的超类</li>
</ol>
<h4 id="翻译规则"><a href="#翻译规则" class="headerlink" title="翻译规则"></a>翻译规则</h4><p>在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-keyword">var</span> prop: Type <span class="hljs-keyword">by</span> MyDelegate()<br>&#125;<br><br><span class="hljs-comment">// 这段是由编译器生成的相应代码：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> prop$delegate = MyDelegate()<br>    <span class="hljs-keyword">var</span> prop: Type<br>        <span class="hljs-keyword">get</span>() = prop$delegate.getValue(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>::prop)<br>        <span class="hljs-keyword">set</span>(value: Type) = prop$delegate.setValue(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>::prop, value)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。</p>
<h4 id="提供委托"><a href="#提供委托" class="headerlink" title="提供委托"></a>提供委托</h4><p>通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。</p>
<p>provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。</p>
<p>例如，如果要在绑定之前检查属性名称，可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceLoader</span>&lt;<span class="hljs-type">T</span>&gt;(id: ResourceID&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDelegate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            thisRef: <span class="hljs-type">MyUI</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            prop: <span class="hljs-type">KProperty</span>&lt;*&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;<br>        checkProperty(thisRef, prop.name)<br>        <span class="hljs-comment">// 创建委托</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkProperty</span><span class="hljs-params">(thisRef: <span class="hljs-type">MyUI</span>, name: <span class="hljs-type">String</span>)</span></span> &#123; …… &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">bindResource</span><span class="hljs-params">(id: <span class="hljs-type">ResourceID</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ResourceLoader&lt;T&gt; &#123; …… &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUI</span> &#123;<br>    <span class="hljs-keyword">val</span> image <span class="hljs-keyword">by</span> bindResource(ResourceID.image_id)<br>    <span class="hljs-keyword">val</span> text <span class="hljs-keyword">by</span> bindResource(ResourceID.text_id)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>provideDelegate 的参数与 getValue 相同：</p>
<ol>
<li>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li>
<li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。<br>在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。</li>
</ol>
<p>如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 检查属性名称而不使用“provideDelegate”功能</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUI</span> &#123;<br>    <span class="hljs-keyword">val</span> image <span class="hljs-keyword">by</span> bindResource(ResourceID.image_id, <span class="hljs-string">&quot;image&quot;</span>)<br>    <span class="hljs-keyword">val</span> text <span class="hljs-keyword">by</span> bindResource(ResourceID.text_id, <span class="hljs-string">&quot;text&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> MyUI.<span class="hljs-title">bindResource</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        id: <span class="hljs-type">ResourceID</span>&lt;<span class="hljs-type">T</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        propertyName: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;<br>   checkProperty(<span class="hljs-keyword">this</span>, propertyName)<br>   <span class="hljs-comment">// 创建委托</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-keyword">var</span> prop: Type <span class="hljs-keyword">by</span> MyDelegate()<br>&#125;<br><br><span class="hljs-comment">// 这段代码是当“provideDelegate”功能可用时</span><br><span class="hljs-comment">// 由编译器生成的代码：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-comment">// 调用“provideDelegate”来创建额外的“delegate”属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> prop$delegate = MyDelegate().provideDelegate(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>::prop)<br>    <span class="hljs-keyword">val</span> prop: Type<br>        <span class="hljs-keyword">get</span>() = prop$delegate.getValue(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>::prop)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/android/">#android</a>
      
        <a href="/tags/kotlin/">#kotlin</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>重拾android路(三十一) Kotlin学习笔记</div>
      <div>http://example.com/2019/07/25/android-31-kotlin/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2019年7月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/07/25/python-01/" title="拥抱Python（一） 介绍">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">拥抱Python（一） 介绍</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/07/19/android-30-thread/" title="重拾android路(三十) Android多线程">
                        <span class="hidden-mobile">重拾android路(三十) Android多线程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
